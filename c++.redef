cdef "^":"#include <unordered_map>
#include <stdexcept>
#include <iostream>
#include <string>
#include <deque>
#include <math.h>
class multi {
	char type;
	std::string data_string;
	double data_double = 0;
	public:
		multi() { type = 'd'; data_double = 0.0; }
		multi(std::string val) { type = 's'; data_string = val; }
		multi(const char* val) { type = 's'; data_string = val; }
		multi(char val) { type = 's'; data_string = std::string(1, val); }
		multi(int val) { type = 'd'; data_double = val; }
		multi(double val) { type = 'd'; data_double = val; }
		operator double() {
			if (type == 'd') { return data_double; }
			else {
				try { return std::stod(data_string); }
				catch (std::invalid_argument&) { return 0.0; }
				catch (std::out_of_range&) { return 0.0; }
			}
		}
		operator std::string() {
			if (type == 's') { return data_string; }
			else {
				try { return std::to_string(data_double); }
				catch (std::invalid_argument&) { return std::string{}; }
			}
		}
		multi operator +(multi arg) {
			if (type == 'd') { return data_double + double(arg); }
			else { return (std::string(*this) + std::string(arg)); }
		}
		multi operator -(multi arg) {
			return (double(*this) - double(arg));
		}
		multi operator *(multi arg) {
			if (type == 'd') { return data_double * double(arg); }
			else {
				std::string res;
				std::string old = *this;
				unsigned long long num = arg;
				for (unsigned int i = 0; i < num; i++) { res += old; }
				return res;
			}
		}
		multi operator /(multi arg) {
			return (double(*this) / double(arg));
		}
		multi operator %(multi arg) {
			return (fmod(double(*this), double(arg)));
		}
		multi operator +=(multi arg) { return *this = *this + arg; }
		multi operator -=(multi arg) { return *this = *this - arg; }
		multi operator *=(multi arg) { return *this = *this * arg; }
		multi operator /=(multi arg) { return *this = *this / arg; }
		multi operator %=(multi arg) { return *this = *this / arg; }
};
std::deque<multi> stack;
std::unordered_map<long long, multi> memory;
std::deque<multi> pop_x(unsigned long long x) {
	std::deque<multi> result;
	unsigned long long size = stack.size();
	for (unsigned long long i = 0; i < x; i++) {
		if (i < size) {
			result.push_back(stack.front());
			stack.pop_front();
		}
		else {
			result.push_back(0.0);
		}
	}
	return result;
}
multi pop() {
	multi value;
	if (stack.size()) {
		value = stack.front();
		stack.pop_front();
	}
	else {}
	return value;
}
void push(multi value) {stack.push_front(value);}
void store(long long key) {
	multi var = pop();
	if (var) { memory[key] = var; }
	else {
		try { memory.erase(key); }
		catch (std::out_of_range&) {}
	}
}
void load(long long key) {
	try { push(memory[key]); }
	catch (std::out_of_range&) { push(0.0); }
}
void plus() { push(pop() + pop()); }
void minus() { push(pop() - pop()); }
void multiply() { push(pop() * pop()); }
void modulo() { push(pop() % pop()); }
void divide() { push(pop() / pop()); }
int main () {
"
cdef "$(?![^.])":"return 0;}"
cdef "(?P<literal_string>'[^'])":"push(\1');"
cdef "(?P<literal_int>[0-9]+(?:\.[0-9]+)?)":"push(\1);"
cdef "\*":"multiply();"
cdef "/":"divide();"
cdef "\+":"plus();"
cdef "\-":"minus();"
cdef "%":"modulo();"
cdef ":=(?P<store>-?[0-9]+(?:\.[0-9]+)?)":"store(\1);"
cdef "=:(?P<load>-?[0-9]+(?:\.[0-9]+)?)":"load(\1);"
cdef "p":"std::cout << std::string(pop()) << std::endl;"
cdef "i":"{std::string input; getline(std::cin, input); push(input); }"
